'use client';

import { useChat } from '@ai-sdk/react';
import { Avatar, Badge, Box, Button, Card, Flex, Spinner, Stack, Text, TextArea } from '@sanity/ui';
import { useEffect, useRef, useState } from 'react';
import ReactMarkdown from 'react-markdown';

// Define our own ToolInvocation interface that includes all properties we need
interface ToolInvocation {
	toolName: string;
	toolCallId: string;
	state: 'partial-call' | 'call' | 'result';
	args: Record<string, any>;
	result?: any;
}

// Custom components have the following props:

// document – an object containing the various document states and their data
// documentId – the ID of the current document
// schemaType – the schema type of the current document
interface CustomSanityComponentProps {
	document: {
		published?: Record<string, any> | null;
		draft?: Record<string, any> | null;
		displayed: Record<string, any>;
		historical?: Record<string, any> | null;
	};
	documentId: string;
	schemaType: Record<string, any>;
}

// Tool-specific components for handling tool invocations
const ContentSuggestionTool = ({ toolInvocation, addToolResult }: { toolInvocation: ToolInvocation, addToolResult?: (result: { toolCallId: string; result: any; }) => void; }) => {
	const { toolCallId, state, args, result } = toolInvocation;

	switch (state) {
		case 'partial-call':
			return (
				<Card padding={3} radius={2} marginY={3} tone="primary">
					<Flex align="center" gap={2}>
						<Text>Generating content suggestions...</Text>
						<Spinner />
					</Flex>
				</Card>
			);
		case 'call':
			return (
				<Card padding={3} radius={2} marginY={3} tone="primary" style={{ background: 'var(--card-bg-color)' }}>
					<Stack space={3}>
						<Flex align="center" gap={2}>
							<Text weight="semibold">Content Suggestions for: </Text>
							<Badge tone="primary">{args.fieldPath}</Badge>
						</Flex>

						{args.requirements && (
							<Card padding={2} radius={2} tone="default">
								<Text size={0} muted>Requirements: {args.requirements}</Text>
							</Card>
						)}

						{/* Show current value if it exists */}
						{args.currentValue && (
							<Card padding={2} radius={2} tone="default">
								<Stack space={1}>
									<Text size={0} muted>Current value:</Text>
									<Text size={1}>{args.currentValue}</Text>
								</Stack>
							</Card>
						)}

						{/* We'll display placeholder for suggestions until they're generated by AI */}
						<Card padding={3} radius={2} border tone="default">
							<Text size={1}>Generating suggestions...</Text>
						</Card>
					</Stack>
				</Card>
			);
		case 'result':
			if (!result || !result.suggestions || !result.suggestions.suggestedOptions) {
				return (
					<Card padding={3} radius={2} marginY={3} tone="caution">
						<Text>No suggestions were generated.</Text>
					</Card>
				);
			}

			return (
				<Card padding={3} radius={2} marginY={3} tone="primary" style={{ background: 'var(--card-bg-color)' }}>
					<Stack space={3}>
						<Flex align="center" gap={2}>
							<Text weight="semibold">Content Suggestions for: </Text>
							<Badge tone="primary">{result.fieldPath || args.fieldPath}</Badge>
						</Flex>

						{result.suggestions.suggestedOptions.map((suggestion: string, index: number) => (
							<Card key={index} padding={3} radius={2} border tone="default">
								<Stack space={2}>
									<Flex align="center" justify="space-between">
										<Text size={1} weight="semibold">Suggestion {index + 1}</Text>
										{addToolResult && (
											<Button
												mode="ghost"
												text="Use This"
												size={0}
												tone="primary"
												onClick={() => {
													addToolResult({
														toolCallId,
														result: { success: true, selection: suggestion, fieldPath: result.fieldPath || args.fieldPath }
													});
												}}
											/>
										)}
									</Flex>
									<Card padding={2} radius={1} tone="default" style={{ background: 'var(--card-code-bg-color)' }}>
										<Text size={1}>{suggestion}</Text>
									</Card>
								</Stack>
							</Card>
						))}
					</Stack>
				</Card>
			);
		default:
			return null;
	}
};

const IncompleteFieldsTool = ({ toolInvocation }: { toolInvocation: ToolInvocation; }) => {
	const { state, args, result } = toolInvocation;

	switch (state) {
		case 'partial-call':
			return (
				<Card padding={3} radius={2} marginY={3} tone="caution">
					<Flex align="center" gap={2}>
						<Text>Analyzing incomplete fields...</Text>
						<Spinner />
					</Flex>
				</Card>
			);
		case 'call':
			return (
				<Card padding={3} radius={2} marginY={3} tone="caution">
					<Text>Checking for incomplete fields in the document...</Text>
				</Card>
			);
		case 'result':
			if (!result || !result.incompleteFields || !result.incompleteFields.length) {
				return (
					<Card padding={3} radius={2} marginY={3} tone="positive">
						<Text>All required fields are complete!</Text>
					</Card>
				);
			}

			return (
				<Card padding={3} radius={2} marginY={3} tone="caution" style={{ background: 'var(--card-bg-color)' }}>
					<Stack space={3}>
						<Flex align="center" gap={2}>
							<Text weight="semibold">Incomplete Fields</Text>
							<Badge tone="caution">{result.totalRequired} required</Badge>
						</Flex>

						{result.incompleteFields.map((field: any, index: number) => (
							<Card key={index} padding={2} radius={2} border tone={field.required ? "caution" : "default"}>
								<Flex align="center" justify="space-between">
									<Stack space={1}>
										<Text size={1} weight="semibold">{field.title}</Text>
										<Text size={0} muted>{field.type}</Text>
									</Stack>
									{field.required && (
										<Badge tone="caution" size={0}>Required</Badge>
									)}
								</Flex>
							</Card>
						))}
					</Stack>
				</Card>
			);
		default:
			return null;
	}
};

const ReferencedFieldTool = ({ toolInvocation }: { toolInvocation: ToolInvocation; }) => {
	const { state, args, result } = toolInvocation;

	switch (state) {
		case 'partial-call':
			return (
				<Card padding={3} radius={2} marginY={3} tone="positive">
					<Flex align="center" gap={2}>
						<Text>Fetching referenced content...</Text>
						<Spinner />
					</Flex>
				</Card>
			);
		case 'call':
			return (
				<Card padding={3} radius={2} marginY={3} tone="positive">
					<Text>Looking up referenced content from {args.referenceFieldPath}...</Text>
				</Card>
			);
		case 'result':
			if (!result || !result.success) {
				return (
					<Card padding={3} radius={2} marginY={3} tone="caution">
						<Text>Failed to fetch referenced content: {result?.message || 'Unknown error'}</Text>
					</Card>
				);
			}

			return (
				<Card padding={3} radius={2} marginY={3} tone="positive" style={{ background: 'var(--card-bg-color)' }}>
					<Stack space={3}>
						<Flex align="center" gap={2}>
							<Text weight="semibold">Referenced Content</Text>
							<Badge tone="positive">{result.referencedDocumentType}</Badge>
						</Flex>

						<Card padding={2} radius={2} border tone="default">
							<Stack space={2}>
								<Text size={0} muted>
									From document: {result.referencedDocumentId.substring(0, 6)}...
								</Text>
								<Text size={0} muted>
									Field: {result.referencedFieldPath}
								</Text>
								<Card padding={2} radius={1} tone="default" style={{ background: 'var(--card-code-bg-color)' }}>
									<Text size={1}>
										{typeof result.value === 'object'
											? JSON.stringify(result.value, null, 2)
											: String(result.value)}
									</Text>
								</Card>
							</Stack>
						</Card>
					</Stack>
				</Card>
			);
		default:
			return null;
	}
};

const WriteFieldTool = ({ toolInvocation }: { toolInvocation: ToolInvocation; }) => {
	const { state, args, result } = toolInvocation;

	switch (state) {
		case 'partial-call':
		case 'call':
			return (
				<Card padding={3} radius={2} marginY={3} tone="primary">
					<Flex align="center" gap={2}>
						<Text>Updating {args?.fieldPath || 'document field'}...</Text>
						<Spinner />
					</Flex>
				</Card>
			);
		case 'result':
			if (!result || !result.success) {
				return (
					<Card padding={3} radius={2} marginY={3} tone="critical">
						<Text>Failed to update field: {result?.message || 'Unknown error'}</Text>
					</Card>
				);
			}

			return (
				<Card padding={3} radius={2} marginY={3} tone="positive">
					<Stack space={2}>
						<Text weight="semibold">Field Updated Successfully</Text>
						<Text size={1}>Updated {result.fieldPath || args.fieldPath} with new value.</Text>
					</Stack>
				</Card>
			);
		default:
			return null;
	}
};

// Component to handle all tool invocations
const ToolInvocationDisplay = ({ toolInvocation, addToolResult }: { toolInvocation: ToolInvocation, addToolResult?: (result: { toolCallId: string; result: any; }) => void; }) => {
	switch (toolInvocation.toolName) {
		case 'suggestContent':
			return <ContentSuggestionTool toolInvocation={toolInvocation} addToolResult={addToolResult} />;
		case 'listIncompleteFields':
			return <IncompleteFieldsTool toolInvocation={toolInvocation} />;
		case 'readSubField':
			return <ReferencedFieldTool toolInvocation={toolInvocation} />;
		case 'writeField':
			return <WriteFieldTool toolInvocation={toolInvocation} />;
		default:
			// Fallback for any tool we don't have a specific component for
			return (
				<Card padding={3} radius={2} marginY={3} tone="default">
					<Stack space={2}>
						<Text weight="semibold">Tool: {toolInvocation.toolName}</Text>
						<Card padding={2} radius={2} tone="default">
							<pre style={{ margin: 0, overflow: 'auto' }}>
								{JSON.stringify(toolInvocation, null, 2)}
							</pre>
						</Card>
					</Stack>
				</Card>
			);
	}
};

// Component to render each message part
const MessagePart = ({ part, addToolResult }: {
	part: {
		type: string;
		text?: string;
		toolInvocation?: ToolInvocation;
	};
	addToolResult?: (result: { toolCallId: string; result: any; }) => void;
}) => {
	switch (part.type) {
		case 'text':
			return (
				<div className="markdown-content">
					<ReactMarkdown>{part.text || ''}</ReactMarkdown>
				</div>
			);
		case 'tool-invocation':
			return part.toolInvocation ?
				<ToolInvocationDisplay toolInvocation={part.toolInvocation} addToolResult={addToolResult} /> :
				null;
		case 'step-start':
			return <div className="step-divider"><hr /></div>;
		default:
			return null;
	}
};

export const ContentCopilotView = (props: CustomSanityComponentProps) => {
	console.log("ContentCopilotView rendering with props:", {
		documentId: props.documentId,
		schemaType: props.schemaType?.name || 'unknown',
		documentExists: !!props.document,
	});

	// Move all hooks to the top level
	const [isLoading, setIsLoading] = useState(false);
	const [conversationId, setConversationId] = useState<string | null>(null);
	const [error, setError] = useState<string | null>(null);
	const [loadAttempt, setLoadAttempt] = useState(0);
	const [isTyping, setIsTyping] = useState(false);
	const messagesEndRef = useRef<HTMLDivElement>(null);
	const textAreaRef = useRef<HTMLTextAreaElement>(null);
	const hasInitialized = useRef(false);

	// Extract safe values from props with defaults
	const documentId = props.documentId || '';
	const schemaType = props.schemaType || { name: 'unknown' };
	const documentData = props.document?.displayed || {};
	const documentType = schemaType.name || 'document';

	const { messages, input, setInput, setMessages, append, handleInputChange, handleSubmit, addToolResult } = useChat({
		api: '/api/content-copilot',
		body: {
			documentData,
			schemaType: { name: schemaType.name },
			documentId,
			conversationId,
		},
		maxSteps: 5,
		id: conversationId || undefined,
		onResponse: (response) => {
			// Extract conversation ID from headers if available
			const newConversationId = response.headers.get('X-Conversation-Id');
			if (newConversationId && (!conversationId || newConversationId !== conversationId)) {
				setConversationId(newConversationId);
			}
			// Show typing indicator
			setIsTyping(true);
		},
		onFinish: () => {
			// Hide typing indicator when response is complete
			setIsTyping(false);
		},
		onError: (error) => {
			console.error("Chat API error:", error);
			setError(`API error: ${error.message}`);
			setIsTyping(false);
		}
	});

	// Check for required props and set error state if missing
	useEffect(() => {
		if (!props.documentId) {
			setError("Missing document ID");
			return;
		}

		if (!props.schemaType) {
			setError("Missing schema type");
			return;
		}

		if (!props.document) {
			setError("Document data unavailable");
			return;
		}

		if (!props.document.displayed) {
			setError("Document data unavailable");
			return;
		}

		// Only load on first render or when explicitly triggered
		if (loadAttempt === 0) {
			setLoadAttempt(1);
		}
	}, [props.documentId, props.schemaType, props.document, loadAttempt]);

	// Load conversation when document changes or retrying
	useEffect(() => {
		if (loadAttempt === 0 || !documentId) return;

		// Reset state for new load
		hasInitialized.current = false;

		const loadConversation = async () => {
			setIsLoading(true);
			setError(null);

			try {
				console.log("Loading conversation for document:", documentId);
				const response = await fetch('/api/content-copilot/get-conversation', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({
						documentId,
						// Pass minimal schema info to avoid circular references
						schemaType: { name: schemaType.name }
					}),
				});

				const data = await response.json();

				if (!response.ok) {
					console.error("Error response from API:", data);
					setError(`Failed to load conversation: ${data.error || response.status}`);
					return;
				}

				console.log("Conversation loaded:", data);
				if (data.conversation) {
					setConversationId(data.conversation.id);
					// If there are previous messages, set them in the chat
					if (data.messages && data.messages.length > 0) {
						// Reset and load the conversation history
						setMessages(data.messages);
					} else {
						// No messages in existing conversation
						setMessages([]);
					}
				} else {
					// No existing conversation
					setMessages([]);
				}
			} catch (error) {
				console.error('Failed to load conversation:', error);
				setError(`Error: ${error instanceof Error ? error.message : String(error)}`);
			} finally {
				setIsLoading(false);
			}
		};

		loadConversation();
	}, [documentId, loadAttempt, schemaType.name, setMessages]);

	// Start a new conversation if no messages exist after loading
	useEffect(() => {
		// Only start a conversation if:
		// 1. Not currently loading
		// 2. No existing messages
		// 3. We haven't already initiated a conversation
		// 4. We have a document ID
		if (!isLoading && messages.length === 0 && !hasInitialized.current && documentId) {
			console.log("Starting initial conversation");
			hasInitialized.current = true;

			// Send an initial message to trigger the AI
			append({
				role: 'user',
				content: `Let's work on this ${documentType}. What should we focus on?`
			}, {
				data: {
					documentData,
					schemaType: { name: schemaType.name },
					documentId,
					conversationId,
				}
			});
		}
	}, [isLoading, messages.length, documentId, documentType, conversationId, documentData, schemaType, append]);

	// Scroll to bottom when messages change
	useEffect(() => {
		if (messagesEndRef.current) {
			messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
		}
	}, [messages, isTyping]);

	// Reset conversation functionality
	const handleResetConversation = async () => {
		if (confirm('Are you sure you want to start a new conversation? This will discard the current conversation history.')) {
			setConversationId(null);
			setMessages([]);
			setError(null);
			hasInitialized.current = false;
		}
	};

	// Retry loading conversation
	const handleRetry = () => {
		setError(null);
		setLoadAttempt(curr => curr + 1);
	};

	// Handle form submission with improved UX
	const handleFormSubmit = (e: React.FormEvent) => {
		e.preventDefault();
		if (!input.trim()) return;

		handleSubmit(e);

		// Focus back on textarea after sending
		setTimeout(() => {
			if (textAreaRef.current) {
				textAreaRef.current.focus();
			}
		}, 0);
	};

	// Auto-grow textarea
	const handleTextAreaInput = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
		handleInputChange(e);

		const target = e.target;
		// Reset height to auto to get proper scrollHeight measurement
		target.style.height = 'auto';
		// Set height based on scrollHeight (plus small buffer)
		target.style.height = `${Math.min(target.scrollHeight + 2, 200)}px`;
	};

	// Handle keyboard shortcuts
	const handleKeyDown = (e: React.KeyboardEvent) => {
		// Submit on Enter (without shift)
		if (e.key === 'Enter' && !e.shiftKey) {
			e.preventDefault();
			handleFormSubmit(e as unknown as React.FormEvent);
		}
	};

	const getDocumentTitle = () => {
		return documentData.title || documentData.name || `Untitled ${documentType}`;
	};

	if (error) {
		return (
			<Card padding={4} radius={2} tone="caution">
				<Stack space={4}>
					<Flex align="center" gap={2}>
						<Text size={2} weight="semibold">AI Assistant Error</Text>
						<Badge tone="critical" size={1}>Error</Badge>
					</Flex>
					<Text size={1}>{error}</Text>
					<Button
						text="Try Again"
						tone="primary"
						onClick={handleRetry}
						style={{ width: 'fit-content' }}
					/>
				</Stack>
			</Card>
		);
	}

	// Try-catch only around rendering
	try {
		return (
			<Card height="fill" style={{ display: 'flex', flexDirection: 'column', width: '100%' }}>
				{/* Header */}
				<Card tone="default" padding={3} borderBottom>
					<Flex align="center" justify="space-between">
						<Flex align="center" gap={2}>
							<Avatar initials="D" size={1} />
							<Stack space={2}>
								<Text size={1} weight="semibold">Dave Assistant</Text>
								<Text size={0} muted>Working with: {getDocumentTitle()}</Text>
							</Stack>
						</Flex>
						{messages.length > 0 && (
							<Button
								mode="bleed"
								text="New Conversation"
								tone="primary"
								onClick={handleResetConversation}
								icon="reset"
								fontSize={1}
							/>
						)}
					</Flex>
				</Card>

				{/* Message area */}
				<Box
					flex={1}
					overflow="auto"
					padding={4}
					style={{
						backgroundColor: 'var(--card-bg-color)',
						display: 'flex',
						flexDirection: 'column',
						width: '100%'
					}}
				>
					{isLoading ? (
						<Flex align="center" justify="center" direction="column" gap={3} style={{ height: '100%' }}>
							<Spinner />
							<Text size={1} muted>Loading conversation...</Text>
						</Flex>
					) : messages.length === 0 ? (
						<Flex
							direction="column"
							align="center"
							justify="center"
							gap={3}
							style={{ height: '100%', textAlign: 'center', maxWidth: '500px', margin: '0 auto' }}
						>
							{hasInitialized.current ? (
								<>
									<Spinner />
									<Text size={1} muted>Starting conversation...</Text>
								</>
							) : (
								<>
									<Avatar initials="D" size={2} />
									<Text size={2} weight="semibold">Initializing conversation...</Text>
									<Text size={1} muted style={{ maxWidth: '400px' }}>
										Dave will help you create and edit content through natural conversation.
									</Text>
								</>
							)}
						</Flex>
					) : (
						<>
							{messages.map((message) => (
								<Flex
									key={message.id}
									direction={message.role === 'user' ? 'row-reverse' : 'row'}
									gap={2}
									marginBottom={4}
								>
									<Avatar
										initials={message.role === 'user' ? 'Y' : 'D'}
										color={message.role === 'user' ? 'blue' : 'gray'}
										size={0}
										style={{ flexShrink: 0, marginTop: '2px' }}
									/>
									<Card
										radius={2}
										shadow={1}
										tone={message.role === 'user' ? 'primary' : 'default'}
										style={{
											maxWidth: '85%',
											marginLeft: message.role === 'user' ? 'auto' : '0',
											marginRight: message.role === 'user' ? '0' : 'auto',
											padding: '12px 16px',
											borderRadius: '14px',
											borderBottomLeftRadius: message.role === 'user' ? '14px' : '2px',
											borderBottomRightRadius: message.role === 'user' ? '2px' : '14px'
										}}
									>
										{message.role === 'user' ? (
											<Text size={1}>{message.content}</Text>
										) : (
											<>
												{message.parts?.map((part, index) => (
													<MessagePart key={index} part={part} addToolResult={addToolResult} />
												)) || (
														// Fallback to support older chat history format that doesn't have parts
														<div className="markdown-content">
															<ReactMarkdown>{message.content}</ReactMarkdown>
														</div>
													)}
											</>
										)}
									</Card>
								</Flex>
							))}

							{isTyping && (
								<Flex direction="row" gap={2} marginBottom={4}>
									<Avatar
										initials="D"
										size={0}
										style={{ flexShrink: 0, marginTop: '2px' }}
									/>
									<Card
										radius={2}
										shadow={1}
										style={{
											maxWidth: '85%',
											padding: '12px 16px',
											borderRadius: '14px',
											borderBottomLeftRadius: '2px'
										}}
									>
										<Flex align="center" gap={2}>
											<Text size={1} muted>Dave is typing</Text>
											<div className="typing-indicator">
												<span></span>
												<span></span>
												<span></span>
											</div>
										</Flex>
									</Card>
								</Flex>
							)}

							<div ref={messagesEndRef} />
						</>
					)}
				</Box>

				{/* Input area */}
				<Card padding={[3, 4]} borderTop style={{ backgroundColor: 'var(--card-bg-color)', width: '100%' }}>
					<form onSubmit={handleFormSubmit} style={{ width: '100%' }}>
						<Flex gap={2} align="flex-end" style={{ width: '100%', display: 'flex' }}>
							<TextArea
								ref={textAreaRef}
								value={input}
								onChange={handleTextAreaInput}
								onKeyDown={handleKeyDown}
								placeholder={isLoading || hasInitialized.current && messages.length === 0 ? "Loading conversation..." : "Message Dave about this content... (Enter to send)"}
								rows={1}
								disabled={isLoading || (hasInitialized.current && messages.length === 0)}
								style={{
									resize: 'none',
									width: '100%',
									minHeight: '44px',
									maxHeight: '200px',
									flex: '1 1 auto',
									padding: '12px',
									borderRadius: '4px',
									border: '1px solid var(--card-border-color)',
									fontSize: '14px',
									lineHeight: '1.4'
								}}
							/>
							<Button
								type="submit"
								icon="arrow-right"
								tone="primary"
								disabled={isLoading || (hasInitialized.current && messages.length === 0) || !input.trim()}
								style={{
									flexShrink: 0,
									flexBasis: 'auto',
									alignSelf: 'flex-end',
									height: '44px',
									width: '44px',
									padding: 0,
									display: 'flex',
									alignItems: 'center',
									justifyContent: 'center'
								}}
							/>
						</Flex>
					</form>
				</Card>

				{/* CSS for typing indicator and markdown */}
				<style jsx global>{`
					.typing-indicator {
						display: flex;
						align-items: center;
					}
					
					.typing-indicator span {
						height: 8px;
						width: 8px;
						background: var(--card-muted-fg-color);
						border-radius: 50%;
						display: inline-block;
						margin-right: 3px;
						animation: bounce 1.3s linear infinite;
					}
					
					.typing-indicator span:nth-child(2) {
						animation-delay: 0.15s;
					}
					
					.typing-indicator span:nth-child(3) {
						animation-delay: 0.3s;
						margin-right: 0;
					}
					
					@keyframes bounce {
						0%, 60%, 100% { transform: translateY(0); }
						30% { transform: translateY(-4px); }
					}
					
					/* Fix for TextArea wrapper spans */
					[data-ui="TextArea"], 
					.InputRoot-sc-1d6h1o8-1 {
						width: 100%;
						flex: 1 1 auto !important;
						display: block;
					}
					
					.markdown-content p {
						margin: 0.5em 0;
					}
					
					.markdown-content p:first-child {
						margin-top: 0;
					}
					
					.markdown-content p:last-child {
						margin-bottom: 0;
					}
					
					.markdown-content pre {
						background: var(--card-code-bg-color, #2d2d2d);
						padding: 0.75em;
						border-radius: 4px;
						overflow-x: auto;
						margin: 0.75em 0;
					}
					
					.markdown-content code {
						font-family: monospace;
						font-size: 0.9em;
						background: var(--card-code-inline-bg-color, rgba(0,0,0,0.05));
						padding: 2px 4px;
						border-radius: 3px;
					}
					
					.markdown-content pre code {
						background: transparent;
						padding: 0;
					}
					
					.markdown-content ul, .markdown-content ol {
						margin: 0.5em 0;
						padding-left: 1.5em;
					}
					
					.step-divider {
						margin: 10px 0;
					}
					
					.step-divider hr {
						border: 0;
						height: 1px;
						background-color: var(--card-border-color);
						margin: 0;
					}
				`}</style>
			</Card>
		);
	} catch (error) {
		console.error("Unexpected error in ContentCopilotView:", error);
		return <div>{`Unexpected error: ${error instanceof Error ? error.message : String(error)}`}</div>;
	}
};

export default ContentCopilotView;

