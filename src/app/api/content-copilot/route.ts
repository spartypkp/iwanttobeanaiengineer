import { createClient } from '@/lib/utils/supabase/server';
import { anthropic } from '@ai-sdk/anthropic';
import { createClient as createSanityClient } from '@sanity/client';
import { Message, streamText, tool } from 'ai';
import { z } from 'zod';

// Initialize Sanity client (ensure this is configured in your environment)
const sanityClient = createSanityClient({
	projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID || '',
	dataset: process.env.NEXT_PUBLIC_SANITY_DATASET || 'production',
	token: process.env.SANITY_API_TOKEN,
	apiVersion: '2023-05-03',
	useCdn: false,
});

// Helper function to build nested patch values
function buildNestedValue(pathParts: string[], finalValue: any): Record<string, any> {
	if (pathParts.length === 1) {
		const result: Record<string, any> = {};
		result[pathParts[0]] = finalValue;
		return result;
	} else {
		const result: Record<string, any> = {};
		result[pathParts[0]] = buildNestedValue(pathParts.slice(1), finalValue);
		return result;
	}
}

// Define interfaces for tool parameters and context
interface ToolContext {
	documentId: string;
	schemaType: { name: string;[key: string]: any; };
}

// Define the tools available to the AI
const writeFieldTool = tool({
	description: 'Update a specific field in the current Sanity document',
	parameters: z.object({
		documentId: z.string().describe('The Sanity document ID for the sanity document you want to update.'),
		fieldPath: z.string().describe('The path to the field (e.g., "title", "description")'),
		value: z.any().describe('The new value to set for the field'),

	}),
	execute: async ({ documentId, fieldPath, value }, { }) => {
		try {
			// Create the patch object based on the field path
			const patch: Record<string, any> = {};
			const parts = fieldPath.split('.');

			// Handle simple field
			if (parts.length === 1) {
				patch[fieldPath] = value;
			}
			// Handle nested fields with set patch
			else {
				patch[`${parts[0]}`] = {
					_type: 'set',
					value: buildNestedValue(parts.slice(1), value)
				};
			}

			// Patch the document
			await sanityClient
				.patch(documentId)
				.set(patch)
				.commit();

			return {
				success: true,
				message: `Successfully updated field ${fieldPath}`,
				value
			};

		} catch (error) {
			console.error('Error writing field:', error);
			return {
				success: false,
				message: `Failed to update field ${fieldPath}: ${error instanceof Error ? error.message : String(error)}`
			};
		}
	}
});

// Tool to suggest content for a field without applying it
const suggestContentTool = tool({
	description: 'Generate content suggestions for a specific field without applying them',
	parameters: z.object({
		documentId: z.string().describe('The Sanity document ID of the document you are editing'),
		fieldPath: z.string().describe('The path to the field you want suggestions for (e.g., "title", "description")'),
		currentValue: z.string().optional().describe('The current content if any exists'),
		fieldType: z.string().describe('The type of the field (e.g., "string", "text", "array")'),
		requirements: z.string().optional().describe('Specific requirements or guidance for the content'),
	}),
	execute: async ({ documentId, fieldPath, currentValue, fieldType, requirements }, { }) => {
		try {
			// Note: This doesn't actually modify the document, just returns suggestions
			// The AI model will generate the content suggestions, this just provides a structured
			// way to present those suggestions to the user

			return {
				success: true,
				message: `Generated suggestions for ${fieldPath}`,
				fieldPath,
				currentValue: currentValue || null,
				// The actual suggestions will be generated by the AI model
				// This is just the structure to organize them in the response
				suggestions: {
					original: currentValue || null,
					fieldType,
					requirements: requirements || null,
					// The AI will generate these values based on the context
					suggestedOptions: [] // This will be filled by the AI model with actual suggestions
				}
			};
		} catch (error) {
			console.error('Error generating suggestions:', error);
			return {
				success: false,
				message: `Failed to generate suggestions for ${fieldPath}: ${error instanceof Error ? error.message : String(error)}`
			};
		}
	}
});

// Define interface for field information
interface SchemaField {
	name: string;
	type: string;
	title: string;
	description?: string;
	required: boolean;
}

// Define interface for incomplete field
interface IncompleteField {
	name: string;
	type: string;
	title: string;
	required: boolean;
}

// Tool to list incomplete or missing fields in the document
const listIncompleteFieldsTool = tool({
	description: 'List fields that are required but empty or incomplete in the document',
	parameters: z.object({
		documentId: z.string().describe('The Sanity document ID of the document you are analyzing'),
		schemaType: z.string().describe('The schema type name of the document (e.g., "project", "skill")'),
		includeOptional: z.boolean().optional().describe('Whether to include optional fields that are empty'),
		focusArea: z.string().optional().describe('Specific area or section to focus on (e.g., "technical", "media")'),
	}),
	execute: async ({ documentId, schemaType, includeOptional, focusArea }, { }) => {
		try {
			// Fetch the document
			const document = await sanityClient.getDocument(documentId);
			if (!document) {
				return {
					success: false,
					message: `Document not found: ${documentId}`
				};
			}

			// Get schema information
			// This would typically come from Sanity's schema, but for this implementation
			// we'll use our extractSchemaInfo function to get field information
			const schemaStructure = await sanityClient.fetch(
				`*[_type == "sanity.documentType" && name == $schemaType][0]`,
				{ schemaType }
			);

			// If schema info isn't available via API, use our helper function with a basic schema
			const mockSchemaType = {
				name: schemaType,
				fields: []
			};

			// For a real implementation, you'd need to either:
			// 1. Use Sanity's schema information API if available
			// 2. Have schema information stored somewhere accessible
			// 3. Hardcode schema expectations for each document type
			const schemaInfo = extractSchemaInfo(schemaStructure || mockSchemaType);

			// Analyze the document for incomplete fields
			const incompleteFields: IncompleteField[] = [];

			if (schemaInfo.fields && Array.isArray(schemaInfo.fields)) {
				schemaInfo.fields.forEach((field: SchemaField) => {
					const isRequired = field.required;
					const fieldValue = document[field.name];
					const isEmpty = fieldValue === undefined || fieldValue === null || fieldValue === '' ||
						(Array.isArray(fieldValue) && fieldValue.length === 0);

					// Add to incomplete fields if required and empty
					if (isRequired && isEmpty) {
						incompleteFields.push({
							name: field.name,
							type: field.type,
							title: field.title,
							required: true,
						});
					}
					// Add optional empty fields if requested
					else if (includeOptional && isEmpty) {
						incompleteFields.push({
							name: field.name,
							type: field.type,
							title: field.title,
							required: false,
						});
					}
				});
			}

			// Filter by focus area if provided
			let filteredFields = incompleteFields;
			if (focusArea) {
				// This is a simple implementation - in a real scenario, you'd have a more
				// sophisticated way to categorize fields by area/section
				filteredFields = incompleteFields.filter(field =>
					field.name.toLowerCase().includes(focusArea.toLowerCase()) ||
					field.title.toLowerCase().includes(focusArea.toLowerCase())
				);
			}

			return {
				success: true,
				message: `Found ${filteredFields.length} incomplete fields`,
				incompleteFields: filteredFields,
				totalIncomplete: incompleteFields.length,
				totalRequired: incompleteFields.filter(f => f.required).length,
				documentId,
				schemaType
			};
		} catch (error) {
			console.error('Error listing incomplete fields:', error);
			return {
				success: false,
				message: `Failed to list incomplete fields: ${error instanceof Error ? error.message : String(error)}`
			};
		}
	}
});

// Tool to read a field from a referenced document
const readSubFieldTool = tool({
	description: 'Read field data from a document referenced by the current document',
	parameters: z.object({
		documentId: z.string().describe('The Sanity document ID of the main document'),
		referenceFieldPath: z.string().describe('The path to the reference field in the main document'),
		referencedFieldPath: z.string().describe('The path to the field in the referenced document you want to read'),
		referenceIndex: z.number().optional().describe('For array references, the index of the reference to use'),
	}),
	execute: async ({ documentId, referenceFieldPath, referencedFieldPath, referenceIndex }, { }) => {
		try {
			// First get the main document
			const document = await sanityClient.getDocument(documentId);
			if (!document) {
				return {
					success: false,
					message: `Document not found: ${documentId}`
				};
			}

			// Get the reference value
			const parts = referenceFieldPath.split('.');
			let refValue: any = document;

			// Navigate to the reference field
			for (const part of parts) {
				if (refValue === undefined || refValue === null) {
					return {
						success: false,
						message: `Reference path ${referenceFieldPath} not found in document`
					};
				}
				refValue = refValue[part];
			}

			// Handle array references if needed
			if (Array.isArray(refValue)) {
				if (referenceIndex !== undefined && referenceIndex >= 0 && referenceIndex < refValue.length) {
					refValue = refValue[referenceIndex];
				} else {
					return {
						success: false,
						message: `Invalid reference index ${referenceIndex} for array of length ${refValue.length}`
					};
				}
			}

			// Get the referenced document ID
			const refId = refValue?._ref;
			if (!refId) {
				return {
					success: false,
					message: `No reference ID found at path ${referenceFieldPath}`
				};
			}

			// Fetch the referenced document
			const referencedDoc = await sanityClient.getDocument(refId);
			if (!referencedDoc) {
				return {
					success: false,
					message: `Referenced document not found with ID: ${refId}`
				};
			}

			// Get the requested field from the referenced document
			const refFieldParts = referencedFieldPath.split('.');
			let fieldValue: any = referencedDoc;

			// Navigate to the field in the referenced document
			for (const part of refFieldParts) {
				if (fieldValue === undefined || fieldValue === null) {
					return {
						success: false,
						message: `Field path ${referencedFieldPath} not found in referenced document`
					};
				}
				fieldValue = fieldValue[part];
			}

			return {
				success: true,
				message: `Successfully read referenced field data`,
				referencedDocumentId: refId,
				referencedDocumentType: referencedDoc._type,
				referencedFieldPath,
				value: fieldValue,
			};
		} catch (error) {
			console.error('Error reading referenced field:', error);
			return {
				success: false,
				message: `Failed to read referenced field: ${error instanceof Error ? error.message : String(error)}`
			};
		}
	}
});

// Define available tools - currently only the writeField tool
const availableTools = {
	writeField: writeFieldTool,
	suggestContent: suggestContentTool,
	listIncompleteFields: listIncompleteFieldsTool,
	readSubField: readSubFieldTool
};

interface ContentCopilotRequest {
	document: {
		published?: Record<string, any> | null;
		draft?: Record<string, any> | null;
		displayed: Record<string, any>;
		historical?: Record<string, any> | null;
	};
	documentId: string;
	schemaType: { name: string;[key: string]: any; };
	conversationId?: string | null;
}

export async function POST(req: Request) {
	const { messages, body }: { messages: Message[]; body: ContentCopilotRequest; } = await req.json();
	const { documentId, schemaType, conversationId } = body;

	console.log('POST content-copilot:', {
		documentId,
		schemaType: schemaType?.name || 'unknown',
		conversationId: conversationId || 'new',
		messageCount: messages.length
	});

	// Initialize Supabase client
	const supabase = await createClient();

	let sessionId: string;

	// Use existing conversation ID if provided
	if (conversationId) {
		sessionId = conversationId;

		// Update the conversation timestamp
		await supabase
			.from('conversations')
			.update({ updated_at: new Date().toISOString() })
			.eq('id', sessionId);
	} else {
		// Create a new conversation record
		const { data: newConversation, error } = await supabase
			.from('conversations')
			.insert({
				title: documentId,
				conversation_type: 'content-copilot',
				context: {
					source: 'sanity',
					documentId,
					schemaType: schemaType.name,
					documentTitle: body.document.displayed?.title || 'Untitled'
				},
				system_prompt: generateSystemPrompt(body)
			})
			.select()
			.single();

		if (error) {
			console.error('Failed to create conversation:', error);
			return new Response(JSON.stringify({ error: 'Failed to create conversation' }), {
				status: 500,
				headers: { 'Content-Type': 'application/json' }
			});
		}

		sessionId = newConversation.id;
		console.log('Created new conversation:', sessionId);
	}

	// Get the last user message to save
	const userMessage = messages.length > 0 ? messages[messages.length - 1] : null;

	// If we have a user message, save it to the database
	if (userMessage && userMessage.role === 'user') {
		const nextSequence = await getNextSequence(supabase, sessionId);
		await supabase.from('messages').insert({
			conversation_id: sessionId,
			external_id: userMessage.id,
			role: 'user',
			content: userMessage.content,
			sequence: nextSequence
		});
		console.log('Saved user message:', { conversationId: sessionId, sequence: nextSequence });
	}

	// Create the stream with callbacks
	const stream = streamText({
		model: anthropic('claude-3-7-sonnet-latest'),
		system: generateSystemPrompt(body),
		messages,
		tools: availableTools,
		maxSteps: 5,
		onFinish: async (result) => {
			// Save the assistant's response
			const nextSequence = await getNextSequence(supabase, sessionId);
			await supabase.from('messages').insert({
				conversation_id: sessionId,
				role: 'assistant',
				content: result.text,
				sequence: nextSequence
			});
			console.log('Saved assistant response:', { conversationId: sessionId, sequence: nextSequence });

			// Update any analytics if needed
			await updateConversationAnalytics(supabase, sessionId);
		}
	});

	// Add conversation ID to the response
	const originalResponse = await stream.toDataStreamResponse();

	// Create a new Response with an additional header containing the conversation ID
	const responseInit = {
		status: originalResponse.status,
		statusText: originalResponse.statusText,
		headers: new Headers(originalResponse.headers)
	};
	responseInit.headers.set('X-Conversation-Id', sessionId);

	return new Response(originalResponse.body, responseInit);
}

// Generate a system prompt based on the document context
function generateSystemPrompt(body: ContentCopilotRequest): string {
	const { documentId, schemaType, document } = body;

	// Extract simplified schema information for the prompt
	const schemaInfo = extractSchemaInfo(schemaType);
	const schemaFieldsDescription = formatSchemaFieldsForPrompt(schemaInfo);

	// Get document completion status
	const completionStatus = analyzeDocumentCompletion(document.displayed, schemaInfo);

	return `
<identity>
You are Dave, Will Diamond's personal AI assistant. You help Will create and edit content for his personal website and portfolio.
</identity>

<context>
You are operating in 'Content Copilot' mode within Sanity Studio, a content management system. Will is using you to help create and edit structured content in a natural, conversational way rather than filling out form fields manually. Content creation is often challenging, and your role is to make this process more intuitive and enjoyable.
</context>

<purpose>
Your primary purpose is to:
1. Reduce the friction of content creation through natural conversation
2. Extract structured information from casual discussions
3. Help refine and improve content iteratively
4. Maintain awareness of document structure and completion status
5. Guide Will through completing all necessary information without overwhelming him
</purpose>

<document_info>
You are currently editing a Sanity document of type: ${schemaType.name}
  Document ID: ${documentId}
  Document Title: ${document.displayed?.title || 'Untitled'}
Completion Status: ${completionStatus.requiredFieldsComplete}/${completionStatus.totalRequiredFields} required fields complete

  Current document data:
  ${JSON.stringify(document.displayed, null, 2)}
</document_info>

<document_schema>
${schemaFieldsDescription}
</document_schema>

<capabilities>
You have access to the following tools:
1. writeField(documentId, fieldPath, value) - Update a specific field in the document
2. suggestContent(documentId, fieldPath, currentValue, fieldType, requirements) - Generate content suggestions for a field without applying them
3. listIncompleteFields(documentId, schemaType, includeOptional, focusArea) - List fields that are required but empty or incomplete
4. readSubField(documentId, referenceFieldPath, referencedFieldPath, referenceIndex) - Read field data from a referenced document
</capabilities>

<conversation_style>
- Maintain a natural, conversational tone rather than a form-filling approach
- Extract relevant information from Will's natural explanations without explicit prompting for each field
- Use progressive disclosure - focus on essential information first, then guide toward additional details
- Switch between these modes as needed:
  * Exploration Mode: Open-ended conversation to gather information naturally
  * Targeted Completion Mode: More directed questions for specific missing fields
  * Refinement Mode: Reviewing and improving existing content

- Show enthusiasm about Will's projects and ideas
- Demonstrate understanding of technical concepts in AI engineering and development
</conversation_style>

<instructions>
- Begin by understanding what Will wants to accomplish with this document
- Extract information from conversation to update multiple relevant fields when possible
- Use listIncompleteFields to identify which fields still need attention
- Suggest improvements for clarity, completeness, and quality using suggestContent
- Help structure content appropriately based on field type and purpose
- When appropriate, propose specific content updates with the writeField tool
- Use readSubField when you need information from related documents
- Never ask for information in a robotic, form-filling manner
- Adapt your approach based on how complete the document already is:
  * For new documents: Focus on core information first before details
  * For partially complete documents: Identify and fill gaps
  * For mostly complete documents: Suggest refinements and improvements
- Always connect your suggestions to improving the overall quality and effectiveness of the content
</instructions>

<examples>
Example 1: Multi-field extraction from conversation
User: "I built a sentiment analysis tool that processes customer reviews and categorizes them as positive, negative, or neutral."
You: "That sounds interesting! When did you build this tool, and what technologies did you use?"
User: "I created it last year using Python, NLTK, and deployed it with Flask on AWS."
[You would then extract and update multiple fields: title, description, technologies, timeline]

Example 2: Suggesting content improvements
User: "I need to improve the description of my project."
You: "Let me help with that. Your current description is quite technical. I can suggest a more accessible version while preserving the technical details. Would that be helpful?"
[You would use suggestContent to provide alternative descriptions]

Example 3: Guiding document completion
User: "What else do I need to add to complete this project?"
[You would use listIncompleteFields to check what's missing]
You: "You've covered the basics well! To complete the project, you still need to add information about the challenges you faced and the results you achieved. Would you like to start with the challenges?"
</examples>

Remember to keep your interactions helpful, natural, and focused on making content creation as seamless as possible. Will should feel like he's having a conversation with a knowledgeable colleague, not filling out a form.
`;
}

// Helper function to analyze document completion status
function analyzeDocumentCompletion(document: any, schemaInfo: any) {
	// Count total required fields and how many are completed
	let totalRequiredFields = 0;
	let requiredFieldsComplete = 0;

	if (schemaInfo.fields && Array.isArray(schemaInfo.fields)) {
		schemaInfo.fields.forEach((field: any) => {
			if (field.required) {
				totalRequiredFields++;

				// Check if the field has a value in the document
				const fieldValue = document[field.name];
				if (fieldValue !== undefined && fieldValue !== null && fieldValue !== '') {
					// For arrays, check if they have items
					if (Array.isArray(fieldValue)) {
						if (fieldValue.length > 0) {
							requiredFieldsComplete++;
						}
					} else {
						requiredFieldsComplete++;
					}
				}
			}
		});
	}

	return {
		totalRequiredFields,
		requiredFieldsComplete,
		percentComplete: totalRequiredFields > 0
			? Math.round((requiredFieldsComplete / totalRequiredFields) * 100)
			: 100
	};
}

// Helper function to extract schema information without circular references
function extractSchemaInfo(schemaType: any) {
	// Basic schema info extraction
	const info = {
		name: schemaType.name,
		title: schemaType.title || schemaType.name,
		type: schemaType.type,
		fields: []
	};

	// Extract fields if available
	if (schemaType.fields && Array.isArray(schemaType.fields)) {
		info.fields = schemaType.fields.map((field: any) => ({
			name: field.name,
			type: field.type,
			title: field.title || field.name,
			description: field.description || '',
			required: getIsRequired(field)
		}));
	}

	return info;
}

// Helper to format schema fields for the prompt
function formatSchemaFieldsForPrompt(schemaInfo: any): string {
	if (!schemaInfo.fields || schemaInfo.fields.length === 0) {
		return '';
	}

	return `
Document schema fields:
${schemaInfo.fields.map((field: any) =>
		`- ${field.name} (${field.type}): ${field.title}${field.required ? ' (required)' : ''}${field.description ? `\n  Description: ${field.description}` : ''}`
	).join('\n')}
`;
}

// Helper to determine if a field is required
function getIsRequired(field: any): boolean {
	if (!field.validation) return false;

	// Check various validation patterns
	if (Array.isArray(field.validation)) {
		return field.validation.some((rule: any) =>
			(rule._rules && rule._rules.some((r: any) => r.flag === 'required')) ||
			(typeof rule === 'function' && rule.toString().includes('required()'))
		);
	}

	return false;
}

// Helper function to get the next sequence number for messages
async function getNextSequence(supabase: any, conversationId: string): Promise<number> {
	const { data, error } = await supabase
		.from('messages')
		.select('sequence')
		.eq('conversation_id', conversationId)
		.order('sequence', { ascending: false })
		.limit(1);

	if (error) {
		console.error('Error getting next sequence:', error);
		return 0;
	}

	return data?.length > 0 ? (data[0].sequence + 1) : 0;
}

// Helper function to update conversation analytics
async function updateConversationAnalytics(supabase: any, conversationId: string) {
	try {
		// Count messages
		const { data: messageCount, error: countError } = await supabase
			.from('messages')
			.select('id', { count: 'exact' })
			.eq('conversation_id', conversationId);

		if (countError) {
			console.error('Error counting messages:', countError);
			return;
		}

		// Check if analytics record exists
		const { data: existingAnalytics, error: existingError } = await supabase
			.from('conversation_analytics')
			.select('id')
			.eq('conversation_id', conversationId)
			.limit(1);

		if (existingError) {
			console.error('Error checking analytics:', existingError);
			return;
		}

		if (existingAnalytics && existingAnalytics.length > 0) {
			// Update existing record
			await supabase
				.from('conversation_analytics')
				.update({
					message_count: messageCount,
					updated_at: new Date().toISOString(),
					model_used: 'claude-3-7-sonnet'
				})
				.eq('conversation_id', conversationId);
		} else {
			// Create new record
			await supabase
				.from('conversation_analytics')
				.insert({
					conversation_id: conversationId,
					message_count: messageCount,
					model_used: 'claude-3-7-sonnet'
				});
		}
	} catch (error) {
		console.error('Failed to update analytics:', error);
	}
}